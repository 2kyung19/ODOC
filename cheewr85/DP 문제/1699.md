## 문제 출처
- https://www.acmicpc.net/problem/1699

## 문제 풀이
- 제곱수를 찾는 문제임, 여기서 제곱수를 찾을 때 그 항의 최소 개수를 출력해야함

- N의 요건은 그보다 작거나 같은 제곱수로 표현을 할 수 있다는 것임 

- 이를 한 번 주어진 예제와 DP 배열을 사용한다고 생각을 하고 그려본다면

![one](/cheewr85/img/thirty.png)

- 조금 난잡해 보이나 여기서 뽑아낸 것은 DP 배열에는 해당 수의 제곱수 표현 시 항의 최소 개수를 저장함

- 그리고 N에 해당하는 제곱수의 최소 항을 계산하기 위해서 DP 배열을 활용함, 여기서 제곱수대로 직접 계산을 한 다음, 이를 비교하는 식으로 함

- 즉, 비교한다는 개념이 만약 1의 제곱에서 계산된 것이 2의 제곱으로 최소항이 된다면 갱신을 하는 식으로 비교를 하면 될 것 같음

- 그리고 조건에 대해서는 N이 그보다 작거나 같은 제곱수의 합으로 나타낼 수 있다는 조건을 활용하면 좀 더 나누기 쉬울 것 같음

- 여기서 아쉽게 막힌 부분이 위의 그림대로 생각까진 했는데 반복문의 조건을 나누는 것과 DP 배열 갱신에 찾질 못함

- 좀 더 체크를 해보았는데 여기서 반복문에 제곱 조건을 걸면 됨

- 즉, j * j <= i를 하게 되면 이중 for문을 돌 때 제곱수인 상황이 아니라면 그냥 그 이전 제곱수의 합으로 계속 체킹이 되는 것임

- 이를 초기에 세팅해주기 위해서 그리고 위 그림에서 보다시피 1인 경우에서 제곱수인 경우를 비교해서 최소값으로 바꾸는 DP 배열이므로 초기값을 1로만 되어있을 때로 세팅을 해 줌

- 그런 다음 제곱수가 된 상황일 때 위의 그림대로 제곱수로 연산이 되는 건데 해당 제곱수는 +1로 당연히 포함하고 그럼 해당 제곱수를 제외하고 최소 항을 확인해야하는데 이는 DP 배열에 다 넣어뒀으므로 해당 값을 체크하면 됨

- 즉, 이를 만약 문제처럼 8을 기준으로 한다면 dp[i] = dp[i-(j*j)] + 1로 8인 경우 dp[8] = dp[8-(2*2)] + 1이 됨, 그림에서 추론한대로

- 그러면 어차피 DP 배열에는 최소항의 개수가 담기므로 이를 풀어보면 dp[8] = dp[4] + 1이 됨, 여기서 1의 역할은 2의 제곱 하나를 추가하는 역할을 함, 제곱수를 통해서 최소항이 갱신되는 것이므로

- 그래서 최소항이 갱신되게끔 최소 개수를 체크하면 됨 이는 다시 보면 dp[8]이 만약 그냥 1로만 이루어진 경우 8인데 그럼 다시 조건을 추론하면 dp[i] > dp[i-(j*j)] + 1일 때 갱신을 해주면 됨

- 이러면 1부터 시작해서 제곱수인 상황에 dp배열을 제곱수의 최소항으로 넣을 수 있게끔 계속 갱신을 할 수 있음, 이를 그대로 코드로 담으면 아래와 같음

```java
import java.io.*;
import java.util.*;

public class Main {

    static int[] dp;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        dp = new int[N+1];

        for(int i = 1; i <= N; i++) {
            // 해당 숫자가 1로만 이루어진 경우(어차피 1루만 이루어진 경우는 해당 수의 개수로 그대로 체크하면 되니깐 i로 그대로 초기화)
            dp[i] = i;
            // j로 제곱수 체크, 여기서 제곱수로 최소항이 변하는 조건은 문제에서 그보다 작거나 같은 값이라고 설명을 함
            // 즉, 여기서 j는 1의 제곱, 2의 제곱, 3의 제곱으로 계속 체크를 할 것이고 제곱수의 딱 걸리는 순간 조건문으로 들어가서 카운팅함
            // 제곱수에 딱 걸리는 시점에 조건문을 쓸 수 있게 j++이 될 것임
            for(int j = 1; j*j <= i; j++) {
                // 여기서 최소항의 개수를 구해야하므로 dp[i]의 기존 값이 새로운 제곱수를 만났을 때, 해당 새로운 제곱수를 뺐을 때의 값을 더했을 때보다 크면 갱신해줘야함
                // 즉, dp[5]는 2의 제곱을 만나기전까지 1만 5번 더해서 dp[5]=5인데
                // 여기서 j=2 즉 2의 제곱인 4를 만나면 5를 제곱수의 최소항으로 4+1로 표현할 수 있음
                // 그때 아래 식에서 +1은 새로운 제곱수를 그리고 dp[i-j*j]는 5-2의 제곱수는 = 1이므로 1일 때 최소항을 의미함
                // 6인 경우로 본다면 6=4+2 즉, 4는 2의 제곱수로 계산하면 되고 2도 역시 제곱수로 이루어졌으니 1+1인 2개인 것
                // 근데 이 개수는 dp배열에 저장했으므로 dp[i-j*j]를 가지고 2의 제곱수를 구하는 것
                if(dp[i] > dp[i-j*j] + 1) dp[i] = dp[i-j*j]+1;
            }
        }

        System.out.println(dp[N]);
    }

}
```

- 반복문에서 제곱수의 조건을 그대로 쓰면 되는 부분이었음, 문제에서 명확하게 그보다 작거나 같은 제곱수라고 하였기 때문에 이를 응용한 것, 그 이외에 점화식이나 규칙을 찾는 그림의 방식은 맞았음