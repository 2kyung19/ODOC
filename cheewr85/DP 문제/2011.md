## 문제 출처
- https://www.acmicpc.net/problem/2011

## 문제 풀이
- 암호코드로써 돌아가는 로직은 이해했는데, 이걸 카운팅을 각각 하는 개념을 감을 전혀 잡지 못했음

- 우선 감을 못 잡은 것은 DP 배열을 쓰는 것이 관건인데 이 부분에 대해서 바로 생각이 나지 않았음

- 좀 더 찾아본 후에 DP 배열을 각 글자를 마지막 숫자로 생각하듯이 채우는 것임 즉, 25114가 입력받았다면 여기서 dp[1] = 1이 됨, 왜냐하면 2만 문자로 변환할 수 있으니 더 알아보면 dp[2]의 경우는 그러면 (2,5),(25) 이렇게 2개를 문자로 나타낼 수 있음, 이런식으로 입력받은 숫자를 체크하면서 DP 배열에 해당 숫자를 문자로 변환시 경우의 수를 넣어주고 이 DP 배열을 응용해서 반복계산을 하고 정답값까지 가면 됨

- 여기서 이를 2차원 배열로 생각할 수 있지만 그럴 필요없이 어차피 25를 2,5로 볼 것인지 25로 볼 것인지 앞의 문자만 비교해주면 되기 때문에 이를 활용하여 1차원 배열로 활용해서 쓸 수 있음

- 그리고 추가적으로 2자리인지 1자리인지도 알아야 하고 어차피 단순하게 숫자와 알파벳의 변환이므로 필요한 경우 이게 숫자로 어느범주인지 체크하기 위해서 정수로 변환해서 체크해도 됨

- 이러한 경우의 수를 종합적으로 따져서 아래와 같이 구조를 생각해 볼 수 있음
![one](/cheewr85/img/thirtythree.png)

- 이 구조와 같이 채워지는데 여기서 점화식을 볼 수 있음, dp[i] = dp[i-1] + dp[i-2]

- 이렇게 되는 것은 i-1로 현재 체크하는 문자와 i-2의 앞 문자를 통해서 암호코드 즉 1 ~ 26에 해당하는지 체크하기 위한 것임

- 그래서 i번째까지 체크했을 때의 수를 기준으로 보는 것, 그리고 암호코드 만약 그림과 같이 dp[3]의 경우 51을 체크해보면 암호코드가 아님, 이 경우는 그냥 dp[2]의 경우를 그대로 붙여서 i-1의 암호코드만 넣어주면 암호코드가 알아서 된 것이므로 이 경우에는 dp[i] = dp[i-1]이 됨을 알 수 있음

- 이 점화식은 일반적으로 이야기 했을 때 말하는 것이고 여기서 한 가지 더 고려할 부분은 0인 경우도 생각을 해줘야함, 왜냐하면 0인 경우는 일단 기본적으로 단독으로 주어졌을 때 암호화 되는 경우가 되지도 않기 때문에 분기로 나뉘어진 암호가 하나로 수렴할 수 밖에 없어짐, 중간에 0이 나오거나 한다면

- 0의 경우를 본다면 아래와 같음
![one](/cheewr85/img/thirtyfour.png)

- 즉, 위의 사례를 본다면 (1,2), (12)가 분기가 된 것이 0이 생기면서 (1,20)만 되버림, 왜냐하면 애초에 0 단독으로 존재할 수 없고 그렇다고 (120)은 아예 성립이 안되기 때문에 하나로 수렴해 버리는 것임 

- 그 여파로 암호화된 코드가 (1, 20)으로 되어 있으니 3이 들어간다고 해도 더 찢어질 수 있는 상황이 아니라서 (1, 20, 3)의 하나만 나오는 것임, 결국 0을 만나게 되면 dp[i]=dp[i-1]이 됨

- 최종적으로 dp[i]가 갱신되는 상황에서 dp[i] = dp[i-2] + dp[i-1]만 해주면 됨, 여기서 dp[i]에서 i는 i까지 했을 때 암호코드가 어떻게 만들어지는지를 보는 것 즉, i=3은 25114 중에 251까지 본 게 3번째 문자인데 여기까지 봤을 때의 경우의 수인거고 이를 확인하고 채우는 작업임, 인덱스 처리로 잘 생각해야함, 실제 인덱스는 다르기 때문에 

- 그리고 조건문을 통해서 0인 경우 문자가 형성될 수 있는지 체크하면서 문제에서 해석할 수 없는 경우는 0으로 출력하라고 했기 때문에 이 경우도 고려를 함

- 이를 코드로 보면 아래와 같음
```java
import java.io.*;
import java.util.*;

public class Main {

    static long[] dp;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String code = br.readLine();

        if(code.charAt(0)=='0') {
            // 0으로 시작하면 잘못된 암호이기 때문에 끝냄
             System.out.println("0");
             return;
        }

        // 문자를 체크하면 어차피 입력받은 문자열을 기준으로 하기 때문에 그에 맞게 크기 초기화시킴
        dp = new long[code.length()+1];

        // 0으로 시작하지 않는다면 암호코드가 성립이 되는 것이므로 초기화 작업을 함
        // 계산을 위해 0도 1로 초기화, 1 즉, 문자가 하나인 경우 성립할 수 있는 암호는 무조건 1이므로 1로 초기화
        dp[0] = dp[1] = 1;

        for(int i = 2; i <= code.length(); i++) {
            // 2번째 문자 체크라해도 인덱스 상 -1이고 그 앞 문자는 인덱스 상 -2이므로 해당 인덱스에 맞게 문자를 받아옴
            char now = code.charAt(i-1);
            char prev = code.charAt(i-2);

            // 만약 문자가 0이라면
            if(now=='0') {
                // 앞의 문자가 1과 2여야만 10, 20으로 체크할 수 있음
                // 그리고 앞 문자 인덱스가 i-2이므로 그 값을 그대로 가져옴, 0만 붙이면 되니깐 굳이 더할 연산 필요 없음
                // i라는 것은 i번째 인 경우를 의미함(i=3이면 3번째 문자인 경우이고, 거기서 실제 인덱스는 i-1 = 2이고 그 앞문자는 i-2=1이므로, 인덱스 처리가 아래와 같음)
                if(prev == '1' || prev == '2') dp[i] = dp[i-2] % 1000000;

                // 1과 2가 아니면 암호코드로 쓸 수도 없을 뿐더러 0 단독 사용도 불가하고 암호코드로 쓸 수 없으므로 잘못된 문자열이어서 종료함
                else break;
            }

            // 문자가 0이 아니고 정상적인 숫자라면
            else {
                // 앞 문자가 0이면 경우의 수 변화 없음, 0으로 인해서 경우의 수가 이전 dp 값 그대로에 현재 값만 붙이는거라서 i-1번째의 경우를 그대로 가져옴
                if(prev == '0') dp[i] = dp[i-1] % 1000000;

                // 앞 문자와 연결할 수 있는지 체크 0이 아닌 경우 두 자리 경우로도 붙일 수 있음
                else {
                    // 앞 문자와 연결할 수 있을 경우 두 자리수인 10~26이므로 int형으로 변환해서 확인
                    int temp = (prev - '0') * 10 + (now - '0');

                    // 위에서 int로 바꾼 값이 암호 코드로 들어올 수 있다면 경우의 수 갱신함
                    // 즉, 25114의 경우 2511의 경우 dp[3]에서 (25 1), (2 5 1)에서 각각 1을 그대로 붙이는 것도 있지만
                    // 위에서 temp의 값이 4번째의 1과 그 앞문자 1을 계산해보면 11인데 이것 역시 암호코드로 변환 가능함, 이것은 dp[2]에 붙일 수 있음 (25 11), (2 5 11)
                    // 그래서 점화식도 dp[i-1] 즉 현재 now만 붙이는 것과 앞문자와 계산시 암호코드에 속하는 두자리수면 dp[i-2]의 경우도 더하는 것
                    if(1 <= temp && temp <= 26)  dp[i] = (dp[i-1] + dp[i-2]) % 1000000;

                    // 만약 이런 두 자리수가 성립이 안된다면 그냥 있던 경우의 수에 가져다가 붙이는 것에 불과하기 때문에 dp[i-1]을 그대로 가져감
                    // dp[i-1] 경우의 now의 값만 붙이면 그 경우는 똑같으므로
                    else dp[i] = dp[i-1] % 1000000;
                }
            }
        }
        // 결국 문자열을 다 읽었을 때의 암호코드의 경우의 수를 출력하므로 그대로 쓰면 됨
        System.out.println(dp[code.length()]%1000000);

    }

}
```