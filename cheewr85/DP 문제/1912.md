## 문제 출처
- https://www.acmicpc.net/problem/1912

## 문제 풀이
- 문제의 로직 자체는 앞서 계속 풀었던 수열 관련 문제와 큰 틀에서 다른점은 없어보임, 여기서 문제는 합을 어떻게 구할 것이냐가 중요함

- 그리고 이 합에 대해서 dp에 저장하면서 마지막에 최대값을 찾는 로직으로 먼저 생각을 했음

- 여기서 아래와 같이 기준을 잡고 합에 대한 결과를 dp에 저장하는 식으로 갱신을 해준다면 dp 배열 i인덱스 기준 합의 최대가 들어가게끔은 생각을 해 볼 수 있음

- 하지만 문제는 이 연속된 수 1개 이상의 조건으로 그 합을 계속해서 비교해주는 것을 dp에서 추가적으로 계산을 해줘야하는데 그 부분이 연결이 안됨

- 즉, 여기서 연속 되는 수를 선택한다는 조건을 놓침, 앞에서 수열 문제처럼 접근을 했기 때문에

![one](/cheewr85/img/twentyfive.png)

- 이 부분에서 걸림돌이 생김, 즉 앞의 수열의 로직은 기준 인덱스를 가지고 하나씩 그 인덱스 기준으로 수열 체크를 하는 것인데 이 문제는 포인트 자체가 다름

- 무슨 이야기냐면 이 문제는 음수, 양수 그리고 특정 인덱스 기준도 아니고 연속적으로 선택한 수의 합이 최대값이 되는 수를 찾는 것임

- 즉, 이전까지 탐색했던 값과 현재 위치의 값을 비교해서 큰 값을 저장하는 로직으로 가야함

- 이 말은 dp배열에 각 인덱스까지의 최대값이 저장되는 것을 의미함, 즉 dp[3]은 값 자체가 dp[0] ~ dp[3]에서 연속으로 선택한 부분 수열의 최댓값이 저장된 것임

- 여기서 포인트는 비교할 때에 있음, 결과적으로 한 개 이상 선택한 상황에서 연속된 몇 개의 수를 선택해서 그 중 가장 큰 합을 찾는 것임 즉, 이 상황에선 음수를 만나면 그 부분이 변곡점이 되어야 함

- 즉 아래와 같이 이전의 것을 비교하는 것 연속된 값만 생각하면 됨, 그리고 여기서 한 가지 더 고려할 부분은 음수의 경우임, 음수를 더하면 현재값보다 적은 상황이 발생할 수 있는데 그땐 현재값보다 적은 경우 그 현재값을 기준으로 다시 합을 체크하면 됨, 그래서 아래와 같이 비교가 되는 것임

![one](/cheewr85/img/twentysix.png)

- 근데 여기서 드는 생각이 3과 -4일 때 연속합이 문제에서 한 개 이상 선택하라고 했기 때문에 그럼 10만을 선택하면 여태까지 합보다 큰 거라서 한 개 이상 선택한거긴 하니깐 dp에 10이 와도 되는게 아닌가라고 생각했었다.

- 하지만 이 전제랑 논리 자체가 아예 배치되는 말이다 연속 합 그리고 문제에서 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하라고 했고 그러면 dp는 이 로직대로 움직여야 하는데 이를 10이 합보다 크다고 10만 고른다는 것은 말이 안된다 결과적으로 3까지 왔을 때의 연속합을 저장해야하는 것이지 그 연속합보다 10이 크고 연속합이 한 개 이상에 어쨌든 10 1개를 고른거니깐 그 값이 큰 게 아니라는 접근 자체가 말이 안됨

- 그 로직은 구현이 힘들 뿐더러 수는 한 개 이상 선택해야 한다는 조건은 처음 시작할 때의 경우를 고르란 것이지 필요한 경우 한 개를 고르라는 의미가 아님, 그럼 그 문제는 연속합이 아님

- 이를 코드로 구현한다면 아래와 같이 됨
```java
import java.io.*;
import java.util.*;

public class Main {

    static int[] arr;
    static int[] dp;


    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        StringTokenizer st;

        arr = new int[N+1];
        dp = new int[N+1];
        st = new StringTokenizer(br.readLine()," ");

        for(int i = 1; i <= N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        // 최대값 초기화
        int max = arr[1];

        for(int i = 1; i <= N; i++) {
            // i부터 시작해서 이전의 연속합과 현재 인덱스 값을 더한 것과 현재 인덱스 값을 비교함
            // dp 배열 자체는 연속합이 되어있는 배열이고 이렇게 비교를 하는 것은 음수가 있기 때문에 음수 때문에 연속합이 완전 작아질 수 있음
            // 만약 연속합이 현재 인덱스 값보다 작다면 현재 인덱스 값부터 다시 계산을 하기 위해서 대소 비교를 계속함
            dp[i] = Math.max(dp[i-1] + arr[i], arr[i]);

            max = Math.max(max, dp[i]);
        }



        System.out.println(max);


    }

}
```