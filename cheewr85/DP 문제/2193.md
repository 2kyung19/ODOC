## 문제 출처
- https://www.acmicpc.net/problem/2193

## 문제 풀이
- 이 문제 역시 이친수라는 수가 성립하는데 있어서 이전의 결과값을 활용하는 것이 중요하기 때문에 조건에 따라서 생각해 볼 수 있음
- 앞서 봤던 오르막수, 계단수를 생각해보면 입력받은 길이를 기준으로 따져본다면 예를 들어서 길이가 2가 되는 경우 길이가 1인 경우에서 파생되는 것이므로 DP로 접근해서 풀 수 있음
- 처음 접근 방식은 아래와 같이 러프하게 진행했음
![one](/cheewr85/img/six.png)

- 하지만 저기서 더 진행을 못하였고 생각만 남겨둠, 그래서 좀 더 세부적으로 분석을 해서 생각을 해 봄
![one](/cheewr85/img/seven.png)
![one](/cheewr85/img/eight.png)

- 이를 코드 상으로 구체화 시키면 아래와 같음
```java
import java.io.*;

public class Main {

    static long[][] dp;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        // DP 배열 초기화(N 자리수가 0,1일 때 개수 카운팅)
        dp = new long[N+1][2];
        
        // N이 1일 때 자릿수가 1일 때 0은 이친수의 시작이 될 수 없으므로 0인 경우는 0 1인 경우 밖에 없음
        dp[1][0] = 0;
        dp[1][1] = 1;
        
        // 입력받은만큼 DP 배열 갱신(메모이제이션 0과 1이 오는 경우의 수에 맞게 중복구조를 통해서 해당 DP값을 활용함)
        for(int i = 2 ; i<=N; i++) {
            // n자리수가 0인 경우 0과 1 둘 다 올 수 있으므로 이전 결과에서 0과 1 이친수에서 덧붙임(2자리수에서 하나 더 붙이면 3자리, 이는 3자리수 성립 위해서 이전 2자리수에 0의 붙은 경우를 말함)
            dp[i][0] = dp[i-1][0] + dp[i-1][1];
            // n자리수가 1인 경우 1은 올 수 없으므로 0인 경우만 추가해줌
            dp[i][1] = dp[i-1][0];
        }

        // 입력 받은 자릿수의 이친수를 출력함
        System.out.println(dp[N][0] + dp[N][1]);

    }

}

```

- 정리를 하자면 위의 그려진 풀이대로 먼저 처음 dp를 초기화 할 때 이친수의 조건으로 인해서 0은 이친수가 못 됨 그래서 1자리수 인 경우 1일 때만 이친수가 1로 초기화됨

- 그리고 이후 자릿수부터 0이냐 1이냐에 따라서 경우의 수가 나뉨 즉, 0인 경우는 앞의 1과 0 둘 다 올 수 있고 1인 경우에는 0만 올 수 있음, 11의 경우 이친수를 위배하는 조건이므로

- 이를 도식화하면 아래와 같이 나타낼 수 있음
![one](/cheewr85/img/nine.png)

- 위의 도식화를 통해서도 알 수 있듯이 이전의 자리수를 활용해서 이친수 성립을 0인 경우, 1인 경우를 나눠서 성립 여부에 따라 계산하므로 위의 반복문과 같이 DP 배열을 갱신할 수 있음

- 최종적으로 입력받은 N자리수의 이친수의 개수를 물어보는 것이므로 0인 경우와 1인 경우 두 케이스를 더하면 이친수의 개수가 나옴