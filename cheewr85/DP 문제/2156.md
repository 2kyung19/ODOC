## 문제 출처
- https://www.acmicpc.net/problem/2156

## 문제 풀이
- 포도주 잔이 있고 여기서 포도주 시식의 규칙이 존재함, 그 잔에 있는 포도주를 모두 마셔야하고, 연속으로 놓여 있는 3잔을 모두 마실 수 없음
- 여기서 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떻게 포도주 잔을 선택해야하는지 알아야함
- 즉 규칙에 맞게 포도주를 선택하고 그 선택한 포도주가 최대가 되도록 하는 문제임
- 우선 직관적으로 입력에 따른 구현은 아래와 같이 생각해 볼 수 있음, 여기서 최대값이 되도록 중간에 체크를 하고 그 합을 반복문에서 더한 다음에 결과를 출력하면 됨
```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int sum = 0;
        for(int i = 1; i <= n; i++) {
            int wine = Integer.parseInt(br.readLine());
            
        }

    }

}

```

- 이 문제도 DP로 풀 수 있는 포인트는 포도주 선택에 따라 있음, 여기서 DP 배열을 활용하여서 누적합을 통해서 최종적으로 최대 결과값을 낸다고 생각을 했음
- 왜냐하면 어쨌든 최대값을 구하는 것이기 때문에 무조건 큰 값만을 고려하는 것 없이 최대한 더하는 것이 중요함, 그래서 어떻게 선택하든 연속으로 3잔만 마시지 않는 선에서 계속 더해주면 좋음
- 아래 정도로 DP를 연산하는 케이스를 생각을 했었지만, 여기서 고민한 것이 그렇다고 무작정 선택하면 안되고 그리고 골랐을 때와 고르지 않았을 때 그리고 3잔 연속 마시는 경우를 피하는 것을 확인해야하는데 구현적으로 생각을 못 했음
- 그렇다고 막연하게 인덱싱 처리를 해버리면 만약 피한 경우에서 큰 값이 들어있을 경우 최대값을 체크를 못하기 때문에 무작정 정형화 할 수 없음, 그리고 이차원 배열로의 접근도 한계가 있음, 연속 체크를 하는 범주가 광범위함
![one](/cheewr85/img/thirteen.png)

- 여기서 이 누적합을 고려할 때 골랐을 때와 안 골랐을 때 생각하는 접근 방식은 맞음, 근데 여기서 경우의 수를 잘 생각해야함, 위에서 생각한 부분과 비슷함, 정형화 할 수 없다. 즉, 마지막 와인잔의 선택이 최대 누적합일수도, 아니면 그 이전 와인잔까지 선택이 최대 누적합일 수 있음
- 즉, 마지막 수를 반드시 거치지 않는다면 그냥 제일 큰 수 2개 뽑아버리는게 최대값이 될 수 있는 것임, 이 부분까지 고려해서 dp 배열에 대해서 다시 한 번 고민을 해봐야함 이말은, 비연속적인 값을 호출한다는 것임
- 결국 최대값은 dp[n]에 나오기 위해서 n번째 경우의 포도주가 최댓값이 나오게 dp 배열을 채워주면 됨, 여기서 위에서 말했듯이 반드시 거치지 않아도 됨 마지막은
- 여기서 중요한 것은 dp 배열은 위에서 말한 조건을 다 지킨 경우임, 즉 여기서 연산에 활용되는 dp 배열의 경우 연속으로 3잔을 고르지 않은 경우임 무조건
- 그럼 이를 n번째를 기준으로 생각을 해보면 아래와 같이 볼 수 있음
![one](/cheewr85/img/thirteen.png)

- 즉, 마신 상태에 대해서 N을 기준으로 나눠서 생각하는 것임, 그리고 마신건지 마시지 않은건지 애매한 상황 외에는 무조건 마셔주는 이유는 가능한 경우에는 다 먹기 위함임, 최대값을 구하니깐
- 그리고 마시거나 마시지 않은 건지 애매한 상황은 결국 누적값이 이미 dp를 통해서 계산을 하기 때문에 애매한 상황에서 먹든 안 먹든 이미 연산이 들어가기 때문에 확실하게 나타난 상황에 대해서만 dp를 생각해주면 됨(만약 N이 4번째 와인이라고 가정을 하면 N-3을 먹을지 말지에 대한 상황에서 N-2의 dp를 연산하면 어차피 N-3의 상황을 dp로 처리했기 때문에 이 상황이 중요한 것이 아님 즉, N-3은 1번째 인 경우의 누적합인데 이는 이미 dp[1]을 의미하는 것이고 이는 dp[4]를 계산했을 때 이미 연산이 완료된 영역이라 마셨는지 안 마셨는지는 중요한 상황이 아님)
- 이런식으로 이전과 비교와 더불어서 와인의 양을 더한 것과 비교하는 등 비연속적으로 확인하면서 최대값을 찾아가면 됨
- 이를 dp 배열과 와인의 배열의 위의 도식화를 점화식화 하게 된다면 dp[i] = dp[i-1], dp[i] = dp[i-2] + wine[i], dp[i] = dp[i-3] + wine[i-1] + wine[i]로 볼 수 있음
- 즉 이 점화식의 경우의 수를 3이상의 인덱스부터 비교를 하면 됨, 그 이전에 1인 경우는 그대로 대입하고 2인 경우는 2개를 더 한 것이 최대이므로 예외처리를 한 뒤에
- 그런식으로 dp[i]를 채움, 그러면 N번째 경우의 와인을 최대로 마실 수 있는 경우만이 선택됨
```java
import java.io.*;
import java.util.*;

public class Main {

    static int[] dp;
    static int[] wines;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        dp = new int[n+1];
        wines = new int[n+1];

        // n만큼 와인의 양 입력받음
        for(int i = 1; i <= n; i++) {
            wines[i] = Integer.parseInt(br.readLine());
        }

        // 초반에는 비교할 변수가 없으므로 바로 대입
        dp[1] = wines[1];

        // n이 2 즉 잔이 2개인 경우 둘 다 마시면 그 값이 최대임
        if(n >= 2) dp[2] = wines[1] + wines[2];

        // 3인 경우부터 고려를 해줘야함, 결과적으로 dp 배열의 마지막 인덱스에 최대값이 저장됨
        // 여기서 도식화 시킨대로 각각 골랐을 때의 경우의 수를 가지고 dp배열에 저장시킴, 여기서 dp 배열에 저장된 값은 해당 경우
        // 즉, 3번째 와인을 선택하는 시점에서 최대로 마실 수 있는 경우에 수가 저장되듯이 dp 배열에는 그 와인을 선택한 시점에서 최대값이 나오는 선택을 함
        // 아래와 같이 복잡해진 이유는 마지막 잔을 꼭 마시지 않아도 되기 때문에 그리고 연속 3잔은 불가능하다는 조건이 겹쳐서 그런 것임
        for(int i = 3; i <= n; i++){
            dp[i] = Math.max(Math.max(dp[i-3] + wines[i-1] + wines[i],dp[i-2] + wines[i]),dp[i-1]);
        }

        System.out.println(dp[n]);

    }

}

```