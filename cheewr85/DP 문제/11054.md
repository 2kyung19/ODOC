## 문제 출처
- https://www.acmicpc.net/problem/11054

## 문제 풀이
- 수열을 처리하는 부분에 있어서 앞서 풀었던 수열 문제가 유사한 로직으로 진행할 수 있음
- 즉, 기준을 잡고 해당 수열이 성립하는지 확인할 수 있음, 입력과 출력의 로직은 동일하게 가져갈 수 있음
- 그 전에 바이토닉 수열에 대해서 이해를 해야하는데 즉 기준 수를 기점으로 오름차순과 내림차순이 나타나면 해당이 됨
- 문제의 예시에서 나온 `{10, 20, 30, 25, 20}` 의 경우를 보면 30을 기준으로 오름차순과 내림차순이 교차로 나타남
- 근데 여기서 중요한 것은 이 부분이 별도로 형성되도 된다는 것임 즉, `{10, 20, 30, 40}`과 `{50, 40, 25, 10}`이 성립되는 것은 40 기준으로 오름차순, 50 기준으로 내림차순이 성립되어서 바이토닉 수열이 가능함
- 이런식으로 기준수를 바탕으로 생각을 해 볼 수 있음, 그리고 이 길이에 대해서도 dp로 저장하는 형식을 생각함
- 그래서 아래와 같이 일단 생각을 해보았음, 기준점을 잡고 앞 뒤를 인덱스로 탐색을 하는 것
![one](/cheewr85/img/DP/twenty.png)

- 하지만 위와 같은 구조의 단점은 만약 2를 탐색할 경우 바이토닉 수열이 5기준으로 길이가 3이 최대값이 되어야 하는데 그렇게 성립을 할 수가 없음, 그렇다고 억지로 껴맞추면 문제에서 주어진대로 판별을 못 함

- 우선 이 기조를 유지하는 것은 맞음, 즉 기준점을 가지고 왼쪽 부분은 오름차순, 오른쪽 부분은 내림차순이라는 이 전제를 가지고 감
- 그러면 여기서 알 수 있는 것은 올라갔다가 내려가는 부분수열을 구해야 하는 것인데 이를 직관적으로 받아들여서 생각할 수 있음
- 즉, 오름차순 이전에 했던 가장 긴 수열과 같이 먼저 그런식으로 수열의 길이를 탐색을 함
- 그러면 왼쪽 부분의 오름차순 즉, 왼쪽에서 오른쪽으로 진행하는 오름차순의 경우를 구할 수 있음, 이는 11053에서의 로직과 완전 동일함
![one](/cheewr85/img/DP/twentyone.png)

- 그리고 내림차순의 경우는 반대로 생각한다면 오른쪽에서 왼쪽으로 진행하는 오름차순 부분수열로 볼 수 있음, 아래와 같이
- 이는 위에서 한 오름차순을 오른쪽에서 왼쪽 즉, 인덱스를 뒤집에서 맨 뒤에부터 순차적으로 탐색을 하면 됨
![one](/cheewr85/img/DP/twentytwo.png)


- 그럼 여기서 최종적으로 이 두 배열을 합치면 됨, 왜냐하면 위에서 바이토닉 수열이 왼쪽으로 오름차순, 오른쪽으로 내림차순이 성립하면 된다고 하였는데 이를 위에서 2가지 방식으로 그대로 구했기 때문에 합치면 되는 것임
![one](/cheewr85/img/DP/twentythree.png)

- 단 여기서 하나 더 알아둬야 할 것은, 단순히 합친 것이므로 원소 1개씩 중복되어 있으므로 1을 빼줘야 하는 부분이 있다는 것임, 그 이유는 아래를 보면 알 수 있음
- 각각 수열에 대해서 합치면 중복은 어차피 같은 것이므로 그 값만 빼고 계산을 하면 되기 때문에 그럼
![one](/cheewr85/img/DP/twentyfour.png)

- 그럼 코드로 하나씩 확인할 수 있음, 어렵게 생각할 것 없이 11053에 로직을 그대로 활용, 반대로 활용하면 됨
- 먼저 일반적인 오름차순으로 길이를 구하는 코드는 아래와 같이 할 수 있음
```java
// 왼쪽부터 오름차순이 되는 값에 대해서 탐색을 함
        for(int i = 1; i <= N; i++) {
            r_dp[i] = 1;
            for(int j = 1; j <= i; j++) {
                // i 기준으로 수열의 길이가 긴 케이스를 체크하고 dp에 갱신해서 dp를 활용해서 해당 인덱스 기준 최대 길이 구함
                if(arr[j] < arr[i] && r_dp[i] < r_dp[j] + 1) {
                    r_dp[i] = r_dp[j] + 1;
                }
            }

        }
```
- 그리고 그 반대 케이스 역시 역순으로 탐색하는 것이므로 인덱스만 바꿔주면 됨
```java
// 오른쪽부터 오름차순 되는 값에 대해서 역순으로 탐색
        for(int i = N; i >= 1; i--) {
            l_dp[i] = 1;
            for(int j = N; j >= i; j--) {
                // i 기준으로 역순으로 탐색을 함
                if(arr[j] < arr[i] && l_dp[i] < l_dp[j] + 1) {
                    l_dp[i] = l_dp[j] + 1;
                }
            }
        }
```

- 그리고 최종적으로 합쳐줄 상황에 대해서도 굳이 dp 배열을 더 써서 할 필요없이, 두 인덱스 값을 합한 것에 대해서 비교를 해서 찾으면 됨, Math.max를 활용해서 합에 대해서 찾음
- 그리고 마지막에 1만 빼주면 됨, 중복값만 제거해주면 되므로
```java
// 최대값을 찾음, 바이토닉 수열이 형성된 상황에서
        int max = -999999;
        for(int i = 1; i <= N; i++ ){
            max = Math.max(r_dp[i] + l_dp[i], max);
        }

        // 마지막에 중복 제외를 위해서 1을 빼줌
        System.out.println(max-1);
```

- 이를 모두 코드로 쓰면 아래와 같음, 입출력의 경우는 이전에 했던 방식과 동일하게 적용함
```java
import java.io.*;
import java.util.*;

public class Main {

    static int[] arr;
    static int[] r_dp;
    static int[] l_dp;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        StringTokenizer st;

        arr = new int[N+1];
        r_dp = new int[N+1];
        l_dp = new int[N+1];

        st = new StringTokenizer(br.readLine()," ");

        for(int i = 1; i <= N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        // 왼쪽부터 오름차순이 되는 값에 대해서 탐색을 함
        for(int i = 1; i <= N; i++) {
            r_dp[i] = 1;
            for(int j = 1; j <= i; j++) {
                // i 기준으로 수열의 길이가 긴 케이스를 체크하고 dp에 갱신해서 dp를 활용해서 해당 인덱스 기준 최대 길이 구함
                if(arr[j] < arr[i] && r_dp[i] < r_dp[j] + 1) {
                    r_dp[i] = r_dp[j] + 1;
                }
            }

        }

        // 오른쪽부터 오름차순 되는 값에 대해서 역순으로 탐색
        for(int i = N; i >= 1; i--) {
            l_dp[i] = 1;
            for(int j = N; j >= i; j--) {
                // i 기준으로 역순으로 탐색을 함
                if(arr[j] < arr[i] && l_dp[i] < l_dp[j] + 1) {
                    l_dp[i] = l_dp[j] + 1;
                }
            }
        }

        // 최대값을 찾음, 바이토닉 수열이 형성된 상황에서
        int max = -999999;
        for(int i = 1; i <= N; i++ ){
            max = Math.max(r_dp[i] + l_dp[i], max);
        }

        // 마지막에 중복 제외를 위해서 1을 빼줌
        System.out.println(max-1);


    }

}
```