## 문제 출처
- https://www.acmicpc.net/problem/11057

## 문제 분석
- 단순하게 규칙을 가지고 1차원 배열로 접근하는 것이 아닌 2차원 배열로써 길이에 따라서 생각을 해보는 것임
- 여기서 오름차순이 될려면 생각해야 할 부분이 어떻게 보면 숫자상으로 가장 맨 뒤에 무엇이 오느냐에 따라 앞에 있는 수에 따라서 오르막 수를 쓸 수 있음
- 그럼 이를 DP의 관점으로 생각해본다면 맨 뒤에 수를 기준으로 잡기 때문에 자연스럽게 그 앞의 숫자가 해당 숫자와 작거나 같은 경우 오르막 수가 됨을 알 수 있음
- 그렇다면 1인 경우는 다 하나씩이라고 하였고 길이가 2인 경우 작거나 같은 경우가 자연스럽게 그 오르막 수가 되기 때문임
- 그럼 이를 코드로 표현한다면 dp[1][1] = 1이 되는 것이고 dp[2][1] = 1개인데 이는 위에서 오르막 수의 조건을 말하면서 작거나 같은 수를 생각한다면 ?1에서 ?들어가는 수가 작거나 같은데 이는 1밖에 없으므로 1이됨
- 이런식으로 인덱스를 기준으로 0 ~ 9까지 훑는다고 가정하고 각각의 DP 배열을 오르막 수가 될 수 있는 개수로 생각하고 채워준다면 길이가 2일 때 ?1인 경우 ?2인 경우를 반복해서 0 ~ 9까지 찾아서 체크를 할 수 있음
```java
import java.io.*;

public class Main {


    static int dp[][];

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        dp = new int[n + 1][10];
        for (int i = 0; i < 10; i++) {
            dp[1][i] = 1;
        }
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j < 10; j++) {
                for (int k = 0; k <= j; k++) {
                    dp[i][j] += dp[i - 1][k];
                    dp[i][j] %= 10007;
                }
            }
        }
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += dp[n][i];
        }
        System.out.println(sum % 10007);
    }


}

```
- 그러다보니 어쩔 수 없이 3중 for문을 쓰게 된 것인데 어쨌든 i는 길이를 그리고 j는 0 ~ 9까지의 수를 그리고 k를 통해서 오르막 수 즉 k가 1인 경우 오르막이 될 수 있는 상황 2인 경우 오르막이 될 수 있는 상황
- 근데 이는 앞서 말했다시피 작거나 같다는 조건이기 때문에 이를 반복문 조건에 걸어줌으로써 바로 계산이 가능함
- 그리고 마지막으로 해당 길이에 대한 총 개수를 더해주면 됨, 각 수에 따라서