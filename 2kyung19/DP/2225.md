## 문제 출처

- https://boj.kr/2225

## 문제 풀이

#### 문제 유형

- `0~N`까지의 정수를 어쩌구 `합`이 되는 `경우의 수`~~ => dp

#### 구현

- 이중배열 [K][n] => K번째 합이 j가 되는 경우를 저장
- dp[1][0:n+1]은 (=1번째 합이 j가 되는 경우의 수) => 1
- dp[1:K+1][0]은 (=i번째 합이 0이 되는 경우의 수) => 1
- dp[1:K+1][1]은 (=i번째 합이 1이 되는 경우의 수) => i
- 나머지는 dp[i-1][j](= i-1번째에 합이 j인 경우의 수) 와 dp[i][j-1] (= i번째 합이 j-1인 경우의 수)에 의 합

#### 기타

- 접근 방식이 비슷한 dp 문제를 풀었었는데 문제 번호를 못찾겠음. 그것보다 쉬운 버전으로 느껴짐

```python
N, K = map(int,input().split())

dp = [[1]*(N+1) for _ in range(K+1)]

for i in range(2,K+1):
    dp[i][1]=i
for i in range(2,K+1):
    for j in range(2,N+1):
        dp[i][j] = dp[i-1][j] + dp[i][j-1]

print(dp[K][N]%1000000000)

```
